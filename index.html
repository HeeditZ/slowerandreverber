<!DOCTYPE html>
<html lang="en">
<!--
¬© 2025 heeditz. all rights reserved.
this repository and its contents are proprietary. 
you may not copy, modify, distribute, or use any part of this project 
without explicit written permission from the owner.
-->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Effects Processor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e1e2e 0%, #2d1b69 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: rgba(30, 30, 46, 0.95);
            border-radius: 24px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            max-width: 700px;
            width: 100%;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        h1 {
            text-align: center;
            color: #a78bfa;
            margin-bottom: 30px;
            font-size: 2em;
            font-weight: 700;
        }

        .upload-area {
            border: 2px dashed rgba(167, 139, 250, 0.5);
            border-radius: 16px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(167, 139, 250, 0.05);
        }

        .upload-area:hover {
            background: rgba(167, 139, 250, 0.1);
            border-color: #a78bfa;
        }

        .upload-area.dragover {
            background: rgba(167, 139, 250, 0.15);
            border-color: #c4b5fd;
        }

        #fileInput {
            display: none;
        }

        .upload-icon {
            font-size: 3em;
            margin-bottom: 10px;
        }

        .upload-area p {
            color: #c4b5fd;
        }

        .controls {
            display: none;
        }

        .controls.active {
            display: block;
        }

        .audio-player {
            background: rgba(167, 139, 250, 0.1);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 30px;
            border: 1px solid rgba(167, 139, 250, 0.2);
        }

        .file-name {
            text-align: center;
            color: #c4b5fd;
            font-weight: 600;
            margin-bottom: 20px;
            font-size: 0.95em;
        }

        .waveform-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            height: 80px;
            margin-bottom: 15px;
            position: relative;
            overflow: hidden;
        }

        .waveform {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(167, 139, 250, 0.5);
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            margin-bottom: 10px;
            cursor: pointer;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #a78bfa 0%, #c4b5fd 100%);
            border-radius: 3px;
            width: 0%;
            transition: width 0.1s linear;
        }

        .time-display {
            display: flex;
            justify-content: space-between;
            color: #9ca3af;
            font-size: 0.85em;
            margin-bottom: 15px;
        }

        .player-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            align-items: center;
        }

        .control-btn {
            background: rgba(167, 139, 250, 0.2);
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #c4b5fd;
            font-size: 1.2em;
        }

        .control-btn:hover {
            background: rgba(167, 139, 250, 0.3);
            transform: scale(1.1);
        }

        .control-btn.play-btn {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #a78bfa 0%, #8b5cf6 100%);
            color: white;
            font-size: 1.5em;
        }

        .control-btn.play-btn:hover {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
        }

        .control-group {
            margin-bottom: 25px;
        }

        .control-group label {
            display: block;
            margin-bottom: 10px;
            color: #c4b5fd;
            font-weight: 600;
            font-size: 0.9em;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #a78bfa;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(167, 139, 250, 0.5);
        }

        .control-group input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #a78bfa;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(167, 139, 250, 0.5);
        }

        .value-display {
            display: inline-block;
            float: right;
            color: #a78bfa;
            font-weight: bold;
        }

        .download-buttons {
            display: flex;
            gap: 12px;
            margin-top: 25px;
        }

        .download-buttons button {
            flex: 1;
            padding: 16px;
            border: none;
            border-radius: 12px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
        }

        .download-buttons button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(16, 185, 129, 0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        button:disabled:hover {
            transform: none;
            box-shadow: none;
        }

        .footer {
            text-align: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            color: #6b7280;
            font-size: 0.8em;
            line-height: 1.6;
        }

        .footer strong {
            color: #a78bfa;
        }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lamejs/1.2.0/lame.min.js"></script>
    <div class="container">
        <h1>üéµ Audio Effects Processor</h1>
        
        <div class="upload-area" id="uploadArea">
            <div class="upload-icon">üéß</div>
            <p><strong>Click to upload</strong> or drag & drop</p>
            <p style="font-size: 0.9em; margin-top: 5px; opacity: 0.7;">MP3, WAV, OGG supported</p>
            <input type="file" id="fileInput" accept="audio/*">
        </div>

        <div class="controls" id="controls">
            <div class="file-name" id="fileName"></div>

            <div class="audio-player">
                <div class="waveform-container">
                    <div class="waveform">üéµ Waveform Visualizer</div>
                </div>
                
                <div class="progress-bar" id="progressBar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                
                <div class="time-display">
                    <span id="currentTime">0:00</span>
                    <span id="duration">0:00</span>
                </div>
                
                <div class="player-controls">
                    <button class="control-btn" id="rewindBtn">‚è™</button>
                    <button class="control-btn play-btn" id="playBtn">‚ñ∂Ô∏è</button>
                    <button class="control-btn" id="forwardBtn">‚è©</button>
                    <button class="control-btn" id="stopBtn">‚èπÔ∏è</button>
                </div>
            </div>

            <div class="control-group">
                <label>
                    Speed
                    <span class="value-display" id="speedValue">1.0x</span>
                </label>
                <input type="range" id="speed" min="0.25" max="2" step="0.05" value="1">
            </div>

            <div class="control-group">
                <label>
                    Pitch
                    <span class="value-display" id="pitchValue">0</span>
                </label>
                <input type="range" id="pitch" min="-12" max="12" step="1" value="0">
            </div>

            <div class="control-group">
                <label>
                    Bass Boost
                    <span class="value-display" id="bassValue">0 dB</span>
                </label>
                <input type="range" id="bass" min="0" max="20" step="1" value="0">
            </div>

            <div class="control-group">
                <label>
                    Reverb
                    <span class="value-display" id="reverbValue">0%</span>
                </label>
                <input type="range" id="reverb" min="0" max="100" step="1" value="0">
            </div>

            <div class="control-group">
                <label>
                    Echo
                    <span class="value-display" id="echoValue">0%</span>
                </label>
                <input type="range" id="echo" min="0" max="100" step="1" value="0">
            </div>

            <div class="control-group">
                <label>
                    Volume
                    <span class="value-display" id="volumeValue">100%</span>
                </label>
                <input type="range" id="volume" min="0" max="200" step="1" value="100">
            </div>

            <div class="download-buttons">
                <button id="downloadWavBtn">‚¨áÔ∏è Download WAV</button>
                <button id="downloadMp3Btn">‚¨áÔ∏è Download MP3</button>
            </div>

            <div class="footer">
                <strong>¬© 2025 heeditz. All rights reserved.</strong><br>
                This repository and its contents are proprietary.<br>
                You may not copy, modify, distribute, or use any part of this project<br>
                without explicit written permission from the owner.
            </div>
        </div>
    </div>

    <script>
        let audioContext;
        let sourceNode;
        let audioBuffer;
        let isPlaying = false;
        let gainNode, bassNode, convolverNode, delayNode, feedbackNode;
        let startTime = 0;
        let pauseTime = 0;
        let animationFrame;

        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const controls = document.getElementById('controls');
        const fileName = document.getElementById('fileName');
        const playBtn = document.getElementById('playBtn');
        const stopBtn = document.getElementById('stopBtn');
        const rewindBtn = document.getElementById('rewindBtn');
        const forwardBtn = document.getElementById('forwardBtn');
        const downloadWavBtn = document.getElementById('downloadWavBtn');
        const downloadMp3Btn = document.getElementById('downloadMp3Btn');
        const progressBar = document.getElementById('progressBar');
        const progressFill = document.getElementById('progressFill');
        const currentTimeDisplay = document.getElementById('currentTime');
        const durationDisplay = document.getElementById('duration');

        // Sliders
        const speedSlider = document.getElementById('speed');
        const pitchSlider = document.getElementById('pitch');
        const bassSlider = document.getElementById('bass');
        const reverbSlider = document.getElementById('reverb');
        const echoSlider = document.getElementById('echo');
        const volumeSlider = document.getElementById('volume');

        // Upload area interactions
        uploadArea.addEventListener('click', () => fileInput.click());

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('audio/')) {
                handleFile(file);
            }
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) handleFile(file);
        });

        async function handleFile(file) {
            fileName.textContent = `üìÅ ${file.name}`;
            
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }

            const arrayBuffer = await file.arrayBuffer();
            audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            
            durationDisplay.textContent = formatTime(audioBuffer.duration);
            controls.classList.add('active');
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function updateProgress() {
            if (!isPlaying || !audioBuffer) return;
            
            const elapsed = audioContext.currentTime - startTime;
            const duration = audioBuffer.duration / parseFloat(speedSlider.value);
            const progress = (elapsed / duration) * 100;
            
            progressFill.style.width = `${Math.min(progress, 100)}%`;
            currentTimeDisplay.textContent = formatTime(elapsed);
            
            if (progress < 100) {
                animationFrame = requestAnimationFrame(updateProgress);
            }
        }

        progressBar.addEventListener('click', (e) => {
            if (!audioBuffer) return;
            const rect = progressBar.getBoundingClientRect();
            const percent = (e.clientX - rect.left) / rect.width;
            const newTime = percent * audioBuffer.duration;
            
            if (isPlaying) {
                stopAudio();
                pauseTime = newTime;
                playAudio();
            } else {
                pauseTime = newTime;
            }
        });

        // Create reverb impulse response
        function createReverbImpulse(duration, decay) {
            const rate = audioContext.sampleRate;
            const length = rate * duration;
            const impulse = audioContext.createBuffer(2, length, rate);
            const left = impulse.getChannelData(0);
            const right = impulse.getChannelData(1);

            for (let i = 0; i < length; i++) {
                left[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
                right[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
            }
            return impulse;
        }

        function playAudio() {
            stopAudio();

            sourceNode = audioContext.createBufferSource();
            sourceNode.buffer = audioBuffer;
            sourceNode.playbackRate.value = parseFloat(speedSlider.value);
            sourceNode.detune.value = parseInt(pitchSlider.value) * 100;

            bassNode = audioContext.createBiquadFilter();
            bassNode.type = 'lowshelf';
            bassNode.frequency.value = 200;
            bassNode.gain.value = parseFloat(bassSlider.value);

            convolverNode = audioContext.createConvolver();
            const reverbAmount = parseFloat(reverbSlider.value) / 100;
            convolverNode.buffer = createReverbImpulse(2, 2);

            const reverbGain = audioContext.createGain();
            reverbGain.gain.value = reverbAmount;

            const dryGain = audioContext.createGain();
            dryGain.gain.value = 1 - reverbAmount * 0.5;

            delayNode = audioContext.createDelay();
            delayNode.delayTime.value = 0.3;
            
            feedbackNode = audioContext.createGain();
            feedbackNode.gain.value = parseFloat(echoSlider.value) / 150;

            const echoGain = audioContext.createGain();
            echoGain.gain.value = parseFloat(echoSlider.value) / 100;

            gainNode = audioContext.createGain();
            gainNode.gain.value = parseFloat(volumeSlider.value) / 100;

            sourceNode.connect(bassNode);
            bassNode.connect(dryGain);
            dryGain.connect(gainNode);
            bassNode.connect(convolverNode);
            convolverNode.connect(reverbGain);
            reverbGain.connect(gainNode);
            bassNode.connect(delayNode);
            delayNode.connect(feedbackNode);
            feedbackNode.connect(delayNode);
            delayNode.connect(echoGain);
            echoGain.connect(gainNode);
            gainNode.connect(audioContext.destination);

            startTime = audioContext.currentTime - pauseTime;
            sourceNode.start(0, pauseTime);
            isPlaying = true;
            playBtn.textContent = '‚è∏Ô∏è';

            updateProgress();

            sourceNode.onended = () => {
                isPlaying = false;
                playBtn.textContent = '‚ñ∂Ô∏è';
                pauseTime = 0;
                progressFill.style.width = '0%';
                currentTimeDisplay.textContent = '0:00';
            };
        }

        function stopAudio() {
            if (sourceNode) {
                try {
                    sourceNode.stop();
                } catch (e) {}
                sourceNode.disconnect();
                sourceNode = null;
            }
            if (bassNode) bassNode.disconnect();
            if (gainNode) gainNode.disconnect();
            if (convolverNode) convolverNode.disconnect();
            if (delayNode) delayNode.disconnect();
            if (feedbackNode) feedbackNode.disconnect();
            
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
            }
            
            isPlaying = false;
            playBtn.textContent = '‚ñ∂Ô∏è';
        }

        playBtn.addEventListener('click', () => {
            if (audioBuffer) {
                if (isPlaying) {
                    pauseTime = audioContext.currentTime - startTime;
                    stopAudio();
                } else {
                    playAudio();
                }
            }
        });

        stopBtn.addEventListener('click', () => {
            stopAudio();
            pauseTime = 0;
            progressFill.style.width = '0%';
            currentTimeDisplay.textContent = '0:00';
        });

        rewindBtn.addEventListener('click', () => {
            if (!audioBuffer) return;
            pauseTime = Math.max(0, pauseTime - 5);
            if (isPlaying) {
                stopAudio();
                playAudio();
            }
        });

        forwardBtn.addEventListener('click', () => {
            if (!audioBuffer) return;
            pauseTime = Math.min(audioBuffer.duration, pauseTime + 5);
            if (isPlaying) {
                stopAudio();
                playAudio();
            }
        });

        // Update value displays
        speedSlider.addEventListener('input', (e) => {
            document.getElementById('speedValue').textContent = `${e.target.value}x`;
            if (isPlaying && sourceNode) {
                sourceNode.playbackRate.value = parseFloat(e.target.value);
            }
        });

        pitchSlider.addEventListener('input', (e) => {
            const value = e.target.value;
            document.getElementById('pitchValue').textContent = value > 0 ? `+${value}` : value;
            if (isPlaying && sourceNode) {
                sourceNode.detune.value = parseInt(value) * 100;
            }
        });

        bassSlider.addEventListener('input', (e) => {
            document.getElementById('bassValue').textContent = `${e.target.value} dB`;
            if (isPlaying && bassNode) {
                bassNode.gain.value = parseFloat(e.target.value);
            }
        });

        reverbSlider.addEventListener('input', (e) => {
            document.getElementById('reverbValue').textContent = `${e.target.value}%`;
        });

        echoSlider.addEventListener('input', (e) => {
            document.getElementById('echoValue').textContent = `${e.target.value}%`;
            if (isPlaying && feedbackNode) {
                feedbackNode.gain.value = parseFloat(e.target.value) / 150;
            }
        });

        volumeSlider.addEventListener('input', (e) => {
            document.getElementById('volumeValue').textContent = `${e.target.value}%`;
            if (isPlaying && gainNode) {
                gainNode.gain.value = parseFloat(e.target.value) / 100;
            }
        });

        // Download WAV functionality
        downloadWavBtn.addEventListener('click', async () => {
            if (!audioBuffer) return;

            downloadWavBtn.disabled = true;
            downloadWavBtn.textContent = '‚è≥ Processing...';

            const renderedBuffer = await renderAudio();
            const wav = audioBufferToWav(renderedBuffer);
            const blob = new Blob([wav], { type: 'audio/wav' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = 'processed_audio.wav';
            a.click();
            URL.revokeObjectURL(url);

            downloadWavBtn.disabled = false;
            downloadWavBtn.textContent = '‚¨áÔ∏è Download WAV';
        });

        // Download MP3 functionality
        downloadMp3Btn.addEventListener('click', async () => {
            if (!audioBuffer) return;

            downloadMp3Btn.disabled = true;
            downloadMp3Btn.textContent = '‚è≥ Encoding MP3...';

            const renderedBuffer = await renderAudio();
            const mp3Data = audioBufferToMp3(renderedBuffer);
            const blob = new Blob([mp3Data], { type: 'audio/mp3' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = 'processed_audio.mp3';
            a.click();
            URL.revokeObjectURL(url);

            downloadMp3Btn.disabled = false;
            downloadMp3Btn.textContent = '‚¨áÔ∏è Download MP3';
        });

        async function renderAudio() {
            const speed = parseFloat(speedSlider.value);
            const outputLength = Math.ceil(audioBuffer.length / speed);
            
            const offlineContext = new OfflineAudioContext(
                audioBuffer.numberOfChannels,
                outputLength,
                audioBuffer.sampleRate
            );

            const offlineSource = offlineContext.createBufferSource();
            offlineSource.buffer = audioBuffer;
            offlineSource.playbackRate.value = speed;
            offlineSource.detune.value = parseInt(pitchSlider.value) * 100;

            const offlineBass = offlineContext.createBiquadFilter();
            offlineBass.type = 'lowshelf';
            offlineBass.frequency.value = 200;
            offlineBass.gain.value = parseFloat(bassSlider.value);

            const offlineGain = offlineContext.createGain();
            offlineGain.gain.value = parseFloat(volumeSlider.value) / 100;

            offlineSource.connect(offlineBass);
            offlineBass.connect(offlineGain);
            offlineGain.connect(offlineContext.destination);

            offlineSource.start();
            return await offlineContext.startRendering();
        }

        function audioBufferToMp3(buffer) {
            const channels = buffer.numberOfChannels;
            const sampleRate = buffer.sampleRate;
            const samples = buffer.length;
            
            const mp3encoder = new lamejs.Mp3Encoder(channels, sampleRate, 128);
            const mp3Data = [];

            const left = buffer.getChannelData(0);
            const right = channels > 1 ? buffer.getChannelData(1) : left;

            const sampleBlockSize = 1152;
            
            for (let i = 0; i < samples; i += sampleBlockSize) {
                const leftChunk = [];
                const rightChunk = [];
                
                for (let j = 0; j < sampleBlockSize && i + j < samples; j++) {
                    leftChunk[j] = left[i + j] * 32767.5;
                    rightChunk[j] = right[i + j] * 32767.5;
                }
                
                const mp3buf = mp3encoder.encodeBuffer(
                    new Int16Array(leftChunk),
                    new Int16Array(rightChunk)
                );
                
                if (mp3buf.length > 0) {
                    mp3Data.push(mp3buf);
                }
            }

            const mp3buf = mp3encoder.flush();
            if (mp3buf.length > 0) {
                mp3Data.push(mp3buf);
            }

            return new Blob(mp3Data, { type: 'audio/mp3' });
        }

        function audioBufferToWav(buffer) {
            const numOfChan = buffer.numberOfChannels;
            const length = buffer.length * numOfChan * 2 + 44;
            const arrayBuffer = new ArrayBuffer(length);
            const view = new DataView(arrayBuffer);
            const channels = [];
            let offset = 0;
            let pos = 0;

            function setUint16(data) {
                view.setUint16(pos, data, true);
                pos += 2;
            }

            function setUint32(data) {
                view.setUint32(pos, data, true);
                pos += 4;
            }

            setUint32(0x46464952);
            setUint32(length - 8);
            setUint32(0x45564157);
            setUint32(0x20746d66);
            setUint32(16);
            setUint16(1);
            setUint16(numOfChan);
            setUint32(buffer.sampleRate);
            setUint32(buffer.sampleRate * 2 * numOfChan);
            setUint16(numOfChan * 2);
            setUint16(16);
            setUint32(0x61746164);
            setUint32(length - pos - 4);

            for (let i = 0; i < buffer.numberOfChannels; i++) {
                channels.push(buffer.getChannelData(i));
            }

            while (pos < length) {
                for (let i = 0; i < numOfChan; i++) {
                    let sample = Math.max(-1, Math.min(1, channels[i][offset]));
                    sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                    view.setInt16(pos, sample, true);
                    pos += 2;
                }
                offset++;
            }

            return arrayBuffer;
        }
    </script>
</body>
</html>
